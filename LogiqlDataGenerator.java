package checkers.inference.solver.LogiqlDebugSolver;

import java.io.File;
import java.io.PrintWriter;
import java.util.Collection;
import java.util.List;

import checkers.inference.model.CombVariableSlot;
import checkers.inference.model.ConstantSlot;
import checkers.inference.model.Constraint;
import checkers.inference.model.RefinementVariableSlot;
import checkers.inference.model.Slot;
import checkers.inference.model.VariableSlot;

/**
 * LogiqlDataGenerator takes Collection<Constraint> and Collection<Slot> of
 * current input program as input, and generate the logiql encoding for this
 * input as data of the predicates generated by LogiqlConstraintGenerator.
 *
 * @author Jianchu Li
 *
 */

public class LogiqlDataGenerator {
    Collection<Slot> slots;
    Collection<Constraint> constraints;
    String path;
    boolean flag;
    int constantSlot;

    public LogiqlDataGenerator(Collection<Slot> slots,
            Collection<Constraint> constraints, String path) {
        this.slots = slots;
        this.constraints = constraints;
        this.path = path;
        flag = false;
        constantSlot = -1;
    }

    public void GenerateLogiqlData() {
        StringBuilder output = new StringBuilder();
        for (Constraint constraint : constraints) {
            List<Slot> slot = constraint.getSlots();
            if (slot.get(0) != slot.get(1)) {
                String[] vStr = new String[3];
                if (constraint.getClass().getSimpleName().contains("CombineConstraint")) {
                    vStr = SlotsToStr(slot, 3);
                } else {
                    vStr = SlotsToStr(slot, 2);
                }
                String nameOfConstraint = getConstraintName(constraint
                        .getClass().getSimpleName());
                if (!nameOfConstraint.contains("preferenceConstraint")) {
                    if (vStr[0] != vStr[1]) {
                        output.append(writeOutputString(nameOfConstraint, vStr,
                                slot));
                    }
                }
            }
            flag = false;
            constantSlot = -1;
        }
        writeFile(output.toString());
    }

    /**
     * writeOutputString generate the logiql encoding for current input program,
     * and write it to String nameOfConstraint.
     * 
     * @param nameOfConstraint
     * @param vStr
     * @param slot
     * @return
     */
    private String writeOutputString(String nameOfConstraint, String[] vStr,
            List<Slot> slot) {
        StringBuilder output = new StringBuilder();
        if (nameOfConstraint.contains("adaptationConstraint")) {
            output.append("+variable(_" + vStr[0] + "),+hasvariableName[_"
                    + vStr[0] + "]=" + vStr[0] + "," + "+variable(_" + vStr[1]
                    + "),+hasvariableName[_" + vStr[1] + "]=" + vStr[1] + ","
                    + "+variable(_" + vStr[2] + "),+hasvariableName[_"
                    + vStr[2] + "]=" + vStr[2] + "," + "+" + nameOfConstraint
                    + "(" + "_" + vStr[0] + "," + "_" + vStr[1] + ",_"+vStr[2]+").\n");
        } 
        else if (flag == true && constantSlot == 0) {
            output.append("+modifier(" + vStr[0] + "),+hasmodifierName["
                    + vStr[0] + "]=" + "\"" + vStr[0] + "\"," + "+variable(_"
                    + vStr[1] + "),+hasvariableName[_" + vStr[1] + "]="
                    + vStr[1] + "," + "+" + nameOfConstraint + "(" + vStr[0]
                    + "," + "_" + vStr[1] + ").\n");
        } else if (flag == true && constantSlot == 1) {
            output.append("+variable(_" + vStr[0] + "),+hasvariableName[_"
                    + vStr[0] + "]=" + vStr[0] + "," + "+modifier(" + vStr[1]
                    + "),+hasmodifierName[" + vStr[1] + "]=" + "\"" + vStr[1]
                    + "\"," + "+" + nameOfConstraint + "(" + "_" + vStr[0]
                    + "," + vStr[1] + ").\n");
        } else {
            output.append("+variable(_" + vStr[0] + "),+hasvariableName[_"
                    + vStr[0] + "]=" + vStr[0] + "," + "+variable(_" + vStr[1]
                    + "),+hasvariableName[_" + vStr[1] + "]=" + vStr[1] + ","
                    + "+" + nameOfConstraint + "(" + "_" + vStr[0] + "," + "_"
                    + vStr[1] + ").\n");
        }
        return output.toString();
    }

    /**
     * Transform two constraint slots to their Id value
     */
    private String[] SlotsToStr(List<Slot> slots, int j) {
        String[] vStr = new String[j];
        for (int i = 0; i < j; i++) {
            if (slots.get(i).getClass().equals(VariableSlot.class)) {
                VariableSlot slot = (VariableSlot) slots.get(i);
                vStr[i] = Integer.toString(slot.getId());
            } else if (slots.get(i).getClass()
                    .equals(RefinementVariableSlot.class)) {
                RefinementVariableSlot slot = (RefinementVariableSlot) slots
                        .get(i);
                vStr[i] = Integer.toString(slot.getId());
            } else if (slots.get(i).getClass().equals(CombVariableSlot.class)) {
                CombVariableSlot slot = (CombVariableSlot) slots.get(i);
                vStr[i] = Integer.toString(slot.getId());
            } else if (slots.get(i).getClass().equals(ConstantSlot.class)) {
                ConstantSlot slot = (ConstantSlot) slots.get(i);
                vStr[i] = slot.getValue().toString().replaceAll("[.@]", "_");
                constantSlot = i;
                flag = true;
            }
        }
        return vStr;
    }

    /**
     * change the name of modifier from type system to the name that can match
     * the encoding from LogiqlConstraintGenerator.
     * 
     * @param simpleName
     * @return
     */

    private String getConstraintName(String simpleName) {
        String nameOfConstraint = "";
        if (simpleName.contains("EqualityConstraint") && flag == false) {
            nameOfConstraint = "equalityConstraint";
        } else if (simpleName.contains("InequalityConstraint") && flag == false) {
            nameOfConstraint = "inequalityConstraint";
        } else if (simpleName.contains("EqualityConstraint") && flag == true) {
            nameOfConstraint = "equalityConstraintContainsModifier";
        } else if (simpleName.contains("InequalityConstraint") && flag == true) {
            nameOfConstraint = "inequalityConstraintContainsModifier";
        } else if (simpleName.contains("SubtypeConstraint")) {
            nameOfConstraint = "subtypeConstraint";
        } else if (simpleName.contains("ComparableConstraint")) {
            nameOfConstraint = "comparableConstraint";
        } else if (simpleName.contains("CombineConstraint")) {
            nameOfConstraint = "adaptationConstraint";
        } else if (simpleName.contains("PreferenceConstraint")) {
            nameOfConstraint = "preferenceConstraint";
        }
        return nameOfConstraint;
    }

    /**
     * write all encoding generated by this class to file data.logic.
     */
    private void writeFile(String output) {
        try {
            String writePath = path + "/data.logic";
            File f = new File(writePath);
            PrintWriter pw = new PrintWriter(f);
            pw.write(output);
            pw.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
